# C++基础 —— 字符串、向量和数组

+ C++语言定义了一个内容丰富的**抽象数据类型库**。其中，`string`和`vector`是两种最重要的标准库类型，**前者支持可变长字符串，后者则表示可变长的集合。**还有一种标准库类型是迭代器，它是string和vector的配套类型，常被用于访问string中的字符或vector中的元素。

## 一、命名空间的using声明

​	目前为止，**我们用到的库函数基本上都属于命名空间std**，而程序也显式地将这一点标示了出来。例如，`std::cin`表示从标准输入中读取内容，此处使用作用域操作符的含义是：**编译器应从操作符左侧名字所示的作用域中寻找右侧那个名字**。因此，**std::cin的意思就是要使用命名空间std中的名字cin。**

上面的方法显得比较烦琐，然而幸运的是，通过更简单的途径也能使用到命名空间中的成员。本节将学习其中一种最安全的方法，也就是**使用`using`声明（using declaration）。**

有了using声明就无须专门的前缀(形如命名空间::)也能使用所需的名字了。

using 声明具有如下形式：

```cpp
using namespace::name;	//一旦声明了上述语句，就可以直接访问命名空间中的名字：
```

示例：

```cpp
#include <iostream>
using std::cin;	//using声明，当我们使用名字cin时，从命名空间std中获取它
int main()
{
    int i;
    cin >> i;	//正确，cin和std::cin含义相同
    cout << i;	//错误，没有对应的using声明，必须使用完整的名字
    std::cout << i;	//正确，显式的从std中使用cout
    return 0;
}
```

**每个名字都需要独立的using声明**

1. 按照规定，每个using声明引入命名空间中的一个成员。例如，可以把要用到的标准库中的名字都以using声明的形式表示出来。

   ```cpp
   #include <iostream>
   using std::cin;
   using std::cout;
   using std::endl;
   int main()
   {
       cout << "Enter two numbers:" << endl;
       int v1, v2;
       cin >> v1 >> v2;
       cout << "The sum of " << v1 << " and " << v2 << " is " << v1 + v2 << endl;
       return 0;
   }
   ```

   + 在上述程序中，一开始就有对cin、cout和endl的using声明，这意味着我们不用再添加std::形式的前缀就能直接使用它们。
   + C++语言形式比较自由，因此既可以一行只放一条using声明语句，也可以一行放上多条。不过要注意，用到的每个名字都必须有自己的声明语句，而且每句话都得以分号结束。

   

   **头文件不应包含using声明**

   ​	**位于头文件的代码一般来说不应该使用using声明。这是因为头文件的内容会拷贝到所有引用它的文件中去，如果头文件里有某个using声明，那么每个使用了该头文件的文件就都会有这个声明。对于某些程序来说，由于不经意间包含了一些名字，反而可能产生始料未及的名字冲突。**



## 二、标准库类型string

### 前言

1. 标准库类型`string`表示可变长的字符序列，使用`string`类型必须首先包含string头文件。

2. 作为标准库的一部分，`string`定义在命名空间std中。

3. 使用标准库类型`string`必备的代码:

   ```cpp
   #include <string>
   using std::string;
   ```

### 定义和初始化string对象

1. **如何初始化类的对象是由类本身决定的**。一个类可以定义很多种初始化对象的方式，只不过这些方式之间必须有所区别，或者是初始值的数量不同，或者是初始值的类型不同。我理解的就是构造函数重载
2. **初始化string对象的方式：:sunglasses:**

1. | 代码                | 备注                                                         |
   | ------------------- | ------------------------------------------------------------ |
   | string s1           | 默认初始化,s1是个空串、string()                              |
   | string s2(s1)       | s2是s1的副本，string(string parm)                            |
   | string s2 = s1      | 等价于string s2(s1), s2是s1的副本                            |
   | string s3("value")  | s3是字面值"value"的副本，除了字面值最后的那个空字符外 string(string parm) |
   | string s3 = "value" | 等价于string("value")                                        |
   | string s4(n, 'c')   | 把s4初始化为由连续的n个字符c组成的串 string(int n, char c)   |

   + 初始化的方式，通过默认初始化的方式、括号传单参数的方式、通过等号赋值的方式、通过括号双参数的方式
   + 感觉对应的构造函数分别是**string()、string(string parm)、string(int num, char c)**

3. **直接初始化和拷贝初始化**

   + **C++语言有几种不同的初始化方式**，通过string我们可以清楚地看到在这些初始化方式之间到底有什么区别和联系。

   + **如果使用等号(=)初始化一个变量，实际上执行的是拷贝初始化。编译器把等号右侧的初始值拷贝到新创建的对象中去。**

   + **如果不使用等号，则执行的是直接初始化(direct initialization)。**

   + **当初始值只有一个时，使用直接初始化或拷贝初始化都行。**

   + ```cpp
     string s5 = "Test"; //拷贝初始化
     string s6("Test");	//直接初始化
     string s7(6, 'c');	//直接初始化，s7的内容是666666
     ```

   + 对于要多个值进行初始化的情况，非要用拷贝初始化的方式来处理也不是不可以，不过需要显式地创建一个（临时）对象用于拷贝：

     ```cpp
     string s8 = string(10, 'c');	//拷贝初始化，s8的内容是cccccccccc
     ```

     等价于

     ```cpp
     string temp(10,'c');	//temp的内容是cccccccccc
     string s8 = temp;		//将temp拷贝给s8
     ```

   + 尽管初始化s8的语句合法，但和初始化s7的方式比较起来可读性较差，也没有任何补偿。
   + **多值初始化尽量还是采用直接初始化，`string s7(6,'c)`这样。**



## 三、标准库类型vector



## 四、迭代器介绍



## 五、数组



## 六、多维数组

