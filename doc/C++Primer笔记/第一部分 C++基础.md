# 第一部分 C++基础

## 前言

1. 公共的语法特征：
   + 整型、字符型等内置类型
   + 变量，用来为对象命名
   + 表达式和语句，用于操纵上述数据类型的具体值
   + if或while等控制结构
   + 函数，用于定义可供随时调用的计算单元

2. 补充基本特征的方法：

   + 赋予程序员自定义数据类型的权利，从而实现对语言的拓展
   + 将一些有用的功能封装成库函数提供给程序员

   

3. **C++是一种静态数据类型语言，它的类型检查发生在编译时**，因此，编译器必须知道程序中每一个变量对应的数据类型

4. C++提供了一组内置数据类型、相应的运算符以及为数不多的几种程序流控制语句，这些元素共同构成了C++语言的基本形态。

5. C++中最重要的语法就是类了，通过它，程序员可以定义自己的数据类型。为了与C++的内置类型区别开来，它们通常被称为"类类型"。



## 一、变量和基本类型

**重要性**：数据类型是程序的基础，它告诉我们数据的意义以及我们能在数据上执行的操作。

**示例：**

```cpp
i = i + j;
/*其含义依赖于i和j的数据类型。如果i和j都是整型数，那么这条语句执行的就是最普通的加法运算；然而， 如果i和j是Sales_item类型的数据，则上述语句把这两个对象的成分相加。*/
```



### 1.基本内置类型

​	C++定义了一套包括**算术类型**(arithmetic type)和**空类型**(void)在内的**基本数据类型**。

+ ###  **算术类型**：**字符**、**整数型**、**布尔值**和**浮点数**

  + 算数类型分为两类：**整型**(包括字符和布尔类型在内)和**浮点型**

  + 算数类型的尺寸(也就是该类型数据所占的比特数)在不同机器上有所差异。

  + | 类型                     | 含义           | 最小尺寸            |
    | ------------------------ | -------------- | ------------------- |
    | bool                     | 布尔类型       | 未定义              |
    | char                     | 字符           | 8位                 |
    | wchar_t                  | 宽字符         | 16位                |
    | char16_t                 | Unicode字符    | 16位                |
    | char32_t                 | Unicode字符    | 32位                |
    | short                    | 短整型         | 16位                |
    | int                      | 整型           | 32位                |
    | long                     | 长整型         | 32位                |
    | long long（C++11新定义） | 长整型         | 64位                |
    | float                    | 单精度浮点型   | 6位有效数字   4字节 |
    | double                   | 双精度浮点型   | 10位有效数字  8字节 |
    | long double              | 拓展经度浮点型 | 10位有效数字 12字节 |

  + bool类型取值为真(true)或假(false)

  + 一个char的大小和一个机器字节一样

  + 其他字符用于拓展字符集，如

    + wchar_t：用于确保可以存放机器最大拓展字符集中的任意一个字符
      + char16_t：为Unicode字符集服务（Unicode用于表示所有自然语言中字符的标准）
      + char32_t：为Unicode字符集服务（Unicode用于表示所有自然语言中字符的标准）

  + **字节(byte)：可寻址的最小内存块，大多数的字节由8比特构成，即1字节是8比特**

  + **字：存储的基本单元,它通常由几个字节组成，大多数的字由32或64比特构成，也就是4或8字节**

  + **大多数计算机将内存中的每个字节与一个数字(被称为地址Address)关联起来。**

  + 在一个字节为8比特，字为32比特的机器上，我们可能看到一个字的内存区域

  + | 字节的地址 | 字节中8比特的具体内容 |
    | ---------- | --------------------- |
    | 736424     | 0 0 1 1 1 0 1 1       |
    | 736425     | 0 0 0 1 1 0 1 1       |
    | 736426     | 0 1 1 1 0 0 0 0       |
    | 736427     | 0 1 1 0 0 1 0 0       |

  + 通常float以1个字(32比特)来表示，double以2个字(64比特)来表示

  + 类型float和double分别有7和16个有效位

  + 带符号类型可以表示正数、负数或0，无符号类型则仅能表示大于等于0的值

  + 类型int、short、long和long long都是带符号，通过在这些类型名前添加unisigned就可以得到无符号类型

  + 类型unsigned int 可以缩写unsigned 

  + 字符型被分为3种：char 、signed char 和 unsigned char 

  + char 和 signed char并不一样，尽管字符有3种，但是字符的表现形式只有2种，带符号和不带符号的。

  + 类型char实际上会表现为上述两种形式中的一种，具体哪种由编译器决定。

  + 无符号类型中所有比特都用来存储值，例如unsigned char 可以表示0-255之间的数值

  + 有符号类型中的signed char 理论上可以表示（-128）---127之间的数

+ **空类型**：空类型不对应具体的值，仅用于一些特殊的场合，例如最常见的是，当函数不返回任何值时使用空类型作为返回类型

+ **如何选择类型**：

  + **当明确知晓数值不可能为负时，选用无符号类型**

  + 使用int执行整数运算。在实际应用中，short常常显得太小而long一般和int有一样的尺寸，如果你的数值超过了int的表示范围，选用long long。

  + **在算术表达式中不要使用char或bool,只有在存放字符或布尔值时才使用它们**。因为char在一些机器上是有符号的，而在另一些机器上又是无符号的，所以如果使用char进行运算特别容易出问题。**如果你需要使用一个不大的整数，那么明确指定它的类型是signed char或者unsigned char。**

  + **执行浮点数运算选用double**，这是因为float通常精度不够而且双精度浮点数和单精度浮点数的计算代价相差无几。事实上，对于某些机器而言，双精度运算甚至比单精度还快。long double提供的精度在一般情况下是没有必要的，况且它带来的运行时消耗也不容忽视。

  + 大多数整型都可以划分为无符号类型和带符号类型，**在无符号类型中所有比特都用来存储数值，但是仅能表示大于等于0的值；**带符号类型则可以表示正数、负数或0。

  + 以0开头的数字是8进制数字，后面的数字取值范围必须是0-7

  + 取模运算：当我们赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。

  + 取模：r = a - c * b, c = a / b(向负无穷方向舍入);求余，c向0方向舍入。

  + 例：

  + ```cpp
    unsigned u1 = 42, u2 = 10;
    std::cout << u2 -u1 << std::endl;
    
    /*
    *u2 - u1 = -32;
    *取模公式：r = a - c * b, c = a / b(向负无穷方向舍入);求余，c向0方向舍入。
    *输出结果为对-32取模后的余数，如果int占32位，上述取模公式中，a = -32, b = 2^32, c = -32/2^32像负无穷方向舍入得c = -1，r = -32 - (-1*2^32) = -32 + 2^32 = -32 + 4294967296 = 4294967264
    */
    ```

  + 数值表示类型示例

  + | 数值  | 描述                                           |
    | ----- | ---------------------------------------------- |
    | 'a'   | 字符a                                          |
    | L'a'  | 宽字符型字面值a且类型是wchar_t                 |
    | "a"   | 字符串a                                        |
    | L"a"  | 表示宽字符型字符串a                            |
    | 10    | 普通的整型类型                                 |
    | 10u   | 表示一个无符号数                               |
    | 10uL  | 表示一个无符号长整型数                         |
    | 012   | 是一个八进制数(对应的10进制数是10)             |
    | 0xC   | 是一个十六进制(对应的10进制数是12)             |
    | 3.14  | 表示一个普通的浮点类型字面值                   |
    | 3.14f | 表示一个float类型的单精度浮点数                |
    | 3.14L | 表示一个long double类型的拓展经度浮点数        |
    | 10.   | 表示一个浮点数                                 |
    | 10e-2 | 科学计数法表示的浮点数，大小为10*10^(-2) = 0.1 |



### 2.类型转换

​	对象的类型定义了对象能包含的数据和能参与的运算，其中一种运算被大多数类型支持，就是将对象从一种特定的类型转换(convert)为另一种相关类型。

​	类型所能表示的值的范围决定了转换的过程：

+ 当我们把一个非布尔类型的算术值赋给布尔类型时，初始值为0则结果为false，否则结果为true。

  ```cpp
  bool b = 66;	//b为真
  bool c = 0;		//c为假
  ```

+ 当我们把一个布尔值赋给非布尔类型时，初始值为false则结果为0，初始值为true则结果为1。

  ```cpp
  bool b1 = true;
  bool b2 = false;
  int n1 = b1;	//n1 = 1
  int n2 = b2;	//n2 = 0
  ```

+ 当我们把一个浮点数赋给整数类型时，进行了近似处理。结果值仅保留浮点数中小数点之前的部分

  ```cpp
  double pi = 3.1415926;
  int num = pi;	//num = 3;
  ```

+ 当我们把一个整数值赋给浮点类型时，小数部分记为0。如果该整数所占的空间超过了浮点类型的容量，精度可能有损失。

  ```cpp
  int n1 = 666;
  int n2 = 655363738;
  float f1 = n1;	//不知为何还是666，而不是666.00
  float f2 = n2;	//6.55364e+008
  ```

+ 当我们赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。例如，8比特大小的unsigned char 可以表示0至255区间的值，如果我们赋了一个区间以外的值，则实际的结果是该值对256取模后所得的余数。因此，把-1赋给8比特的unsigned char所得的结果是255。

  ```cpp
  unsigned char c = -1;	//假设char占8比特，c的值为255
  ```

+ 当我们赋给带符号类型一个超出它表示范围的值时，结果是未定义的，此时，程序可能继续工作、可能崩溃，也可能生成垃圾数据。

  ```cpp
  signed char c2 = 256; 	//假设char占8比特，c2的值是未定义的
  ```

+ 含有无符号类型的表达式

  + 尽管我们不会故意给无符号对象赋一个负值，却可能(特别容易)写出这么做的代码。

  + 例如，当一个算术表达式中既有无符号数又有int值时，那个int值就会转换成无符号数。把int转换成无符号数的过程和把int直接给无符号变量一样：

    ```cpp
    unsigned u = 10;
    int i = -42;
    std::cout << i + i << std::endl;	//输出-84
    
    /*1.相加前首先把整数-42转换成无符号数。
    **2.把负数转换成无符号数类似于直接给无符号数赋一个负值
    **3.结果等于这个负数加上无符号数的模
    */
    std::cout << u + i << std::endl;	//如果int占32位，输出4294967264
    ```

  + for()或者while()循环中避免使用unsigned 类型的变量

    ```cpp
    for (int i = 10; i >= 0; i--)
        std::cout << i << std::endl;	//输出10 9 8 7 6 5 4 3 2 1 
    
    for (unsigned int i = 10; i >= 0; i--)	//死循环，变量i永远也不会小于0，循环条件一直成立
        std::cout << i << std::endl;
    ```

    + 切勿混用带符号类型和无符号类型
      + 如果表达式中既有带符号类型又有无符号类型，当带符号类型取值为负时会出现异常结果，这是因为带符号数会自动地转换成无符号数。
      + 例如：在一个形如a*b的式子中，如果a = -1,b = 1,而且a和b都是int,则表达式的值显然为-1。然而，如果a是int,而b是unsigned int，则结果须视在当前机器上int所占位数而定。在我们的环境中，结果是4294967295

### 3.字面值常量

+ 一个形如42的值被称作字面值常量，这样的一望而知。每个字面值常量都对应一种数据类型，字面值常量的形式和值决定了它的数据类型。

+ 整型和浮点型字面值

  + 我们可以把整型字面值写作十进制数、八进制数或十六进制数的形式。

    八进制数：以0开头的整数 	例如024

    十六进制数：以0x或0X开头的整数	例如0x14

+ 字符和字符串字面值
  + 由单引号括起来的一个字符称为char型字面值，'a'	字符字面值
  + 双引号括起来的零个或多个字符则构成字符串型字面值  "Hello World！"    字符串字面值

+ 转义序列

+ | 符号 | 描述         |
  | ---- | ------------ |
  | \n   | 换行符       |
  | \t   | 横向制表符   |
  | \a   | 报警(响铃)符 |
  | \v   | 纵向制表符   |
  | \b   | 退格符       |
  | \\"" | 双引号       |
  | \\'  | 单引号       |
  | \\?  | 问号         |
  | \\   | 反斜线       |
  | \r   | 回车符       |
  | \f   | 进纸符       |

+ 指定字面值的类型

  | 前缀     | 含义                        | 类型     | 示例       |
  | -------- | --------------------------- | -------- | ---------- |
  | u        | Unicode 16字符              | char16_t |            |
  | U        | Unicode 32字符              | char32_t |            |
  | L        | 宽字符                      | wchat_t  | L‘a’       |
  | u8       | UTF-8(仅用于字符串字面常量) | char     | u8"hi!"    |
  |          |                             |          |            |
  | 后缀     | 最小匹配类型                |          |            |
  | u or U   | unsigned                    |          |            |
  | l or L   | long                        |          |            |
  | ll or LL | long long                   |          |            |
  |          |                             |          |            |
  | 后缀     | 类型                        |          |            |
  | f或F     | float                       |          | 1E-3F      |
  | l或L     | long double                 |          | 3.1415926l |

  + 当使用一个长整型字面值时，请使用大写字母L来标记，因为小写字母l和数字1太容易混淆了。

+ 布尔的字面值

  + true和false是布尔类型的字面值

+ 指针的字面值

  + nullptr是指针字面值

### 4.变量定义(列表初始化):grin:

+ 变量提供一个具名的、可供程序操作的存储空间。

+ C++中每个变量都有其数据类型，数据类型决定着变量所占内存空间的大小和布局方式、该空间能存储的值的范围，以及变量能参与的运算。对C++程序员来说，“变量(variable)”和"对象(object)"一般可以互换使用。

+ **何为对象**

  + C++程序员们在很多场所都会使用对象(object)这个名词。通常情况下，**对象是指一块能存储数据并具有某种类型的内存空间。**
  + 当对象在创建时获得了一个特定的值，我们就说这个对象被初始化了。

+ 初始化和赋值的区别

  + 初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代。

+ 列表初始化

  + C++语言定义了初始化的好几种不同形式，例如

  + ```cpp
    int units_sold = 0;
    int units_sold = {0};	//C++11新特性，全面应用，这种初始化的形式被称为列表初始化
    int units_sold{0};
    int units_sold(0);
    ```

  + 现在无论是初始化对象还是某些时候为对象赋新值，都可以用这样一组由花括号括起来的初始化值了。

  + 当用于内置类型的变量时，这种初始化形式有一个重要特点：如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器会报错。

    + ```cpp
      long double ld = 3.1415926536;
      /*如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器会报错。*/
      int a{ld}, b = {ld};	//错误，转换未执行，因为存在丢失信息的风险
      
      int c(ld),d = ld;		//正确，转换执行，且确实丢失了部分值
      ```

  + 默认初始值

    ​	如果定义变量时没有指定初值，则变量被默认初始化，此时变量被赋予了默认值。默认值到底是什么由变量类型决定，同时定义变量的位置也会对此有影响。

    + 如果是内置类型的变量未被显式初始化，它的值由定义的位置决定。定义于任何函数体之外的变量都被初始化为0。
    + 一种例外情况，定义在函数体内部的内置类型变量将不被初始化。一个未被初始化的内置类型变量的值是未定义的，如果试图拷贝或以其他形式访问此类值将引发错误。
    + string类型的变量，因为string类型本身接受无参数的初始化方式，所以变量定义在函数体内还是函数体外都被默认定义为空串

  

### 5.变量声明和定义的关系

​	为了允许把程序拆分成多个逻辑部分来编写，c++语言支持分离式编译机制（该机制允许将程序分割为若干个文件，每个文件可单独编译）。

+ **声明**：使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明

  + 声明规定了变量的类型和名字，不申请存储空间

+ **定义**：负责创建与名字关联的实体

  + 定义规定了变量的类型和名字，申请存储空间，也可能会为变量赋一个初始值

  **声明不定义**：

  + 如果想声明一个变量而非定义它，就在变量名前添加关键字extern，而且不要显式的初始化变量

    + ```cpp
      extern int i;	//声明i而非定义i
      int j;			//声明并定义j
      ```

+ **说明：**

  + 任何包含显式初始化的声明即成为定义。

  + 给由extern关键字标记的变量赋一个初始值，但是这么做也就抵消了extern的作用。extern语句如果包含初始值就不再是声明，而变成定义了：

    + ```cpp
      extern double pi = 3.1416; //定义
      ```

    + 在函数体内部，如果试图初始化一个由extern关键字标记的变量，将引发错误。

    + 变量且只能被定义一次，但是可以被多次声明。

      + C++是一种静态类型语言，其含义是在编译阶段检查类型。其中，检查类型的过程称为类型检查。

### 6.变量命名规范:grin:

+ 标识符要能体现实际含义
+ 变量名一般用小写字母，如index，不要使用Index或INDEX。
+ 用户自定义的类名一般以大写字母开头，如Sales_item
+ 如果标识符由多个单词组成，则单词间应有明显区分，如student_loan或studentLoan,不要使用studentloan

### 7. 复合类型:grin:

​	复合类型是指基于其它类型定义的类型。C++语言有几种复合类型，主要说下其中的两种：引用和指针。

#### 引用

​	C++11中新增了一种引用：所谓的"右值引用"

##### 定义

​	引用(reference)为对象起了另外一个名字，引用类型引用另外一种类型。通过将声明符写成&d的形式来定义引用类型，其中d是声明的变量名。

```cpp
int ival = 1024;
int &refVal = ival;		//refVal指向ival(是ival的另一个名字)
int &refVal2;			//报错：引用必须初始化
```

+ 一般在初始化变量时，初始值会被拷贝到新建的对象中。然而定义引用时，程序把引用和它的初始值绑定在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另外一个对象，因此引用必须初始化。
+ 引用必须指向一个实际存在的对象而非字面值常量。如`int &refVal = 1.01`就是错误的。
+ 因为我们无法令引用重新绑定到另外一个对象，所以引用必须初始化。如`int &refVal2;`就是错误的

##### 引用即别名

​	引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字。

##### 重要:sunglasses:

```cpp
int i = 0, &r1 = i;
double d = 0, &r2 = d;

r2 = 3.14159;	//引用赋值实际上是把值赋给了与引用绑定的对象，在这里是把3.14159赋给了变量d
r2 = r1;	//以引用作为初始值实际上是以引用绑定的对象作为初始值，在这里是把i的值赋给了变量d
i = r2;		//把d的值赋给了变量i,因为d是双精度浮点数而i是整数，所以该语句实际上执行了窄化操作
r1 = d;		//把d的值赋给了变量i，与上一条语句一样执行了窄化操作
```

+ **说白了，操作引用相当于操作与引用绑定的对象**

+ **引用不是对象，它只是为已经存在的对象起了另外一个名字**

+ **引用本身并非对象，一旦定义了引用，就无法令其再绑定到另外一个对象，之后每次使用这个引用都是访问它最初绑定的那个对象。**

  ```cpp
  int i, &ri = i;
  i = 5;
  ri = 10;
  std::cout << i << " " << ri << std::endl;
  
  /*解析：引用不是对象，它只是为已经存在的对象起了另外一个名字，即ri就是i,把ri当成i用
  **首先将i赋值为5，然后通过ri = 10(相当于把ri看成i , i = 10)把i这个值更新为10，因此ri是i的引用
  **所以它们输出结果是一样的。
  **result :	10 10
  */
  ```



#### 指针

##### 定义

​	指针是指向另外一种类型的复合类型。与引用相比，指针也实现了对其它对象的间接访问。

##### 指针与引用不同

+ 指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象
+ 指针无需在定义时赋初值，和其它内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。

##### 获取对象的地址

+ 指针存放某个对象的地址，要想获取该地址，需要使用取地址符(操作符&)

  + ```cpp
    int iVal = 66;
    int *p = &iVal;	//p存放变量iVal的地址，或者说p是指向变量iVal的指针
    ```

+ 指针本身类型都要和它所指向的对象严格匹配

  + ```cpp
    double dval;
    double *pd = &dval;		//正确，初始值是double型对象的地址
    double *pd2 = pd;		//正确，初始值是指向double对象的指针
    
    int *pi = pd;		//错误，指针pi的类型和pd的类型不匹配
    pi = &dval;			//错误，试图把double型对象的地址赋给int型指针
    ```

  + 因为在声明语句中指针的类型实际上被用于指定它所指向对象的类型，所以二者必须匹配。如果指针指向了一个其他类型的对象，对该对象的操作将发生错误。

##### 指针值

​	指针的值(即地址)应属下列4种状态之一：

1. 指向一个对象。
2. 指向紧邻对象所占空间的下一个位置。
3. 空指针，意味着指针没有指向任何对象。
4. 无效指针，也就是上述情况之外的其他值。

##### 利用指针访问对象

1. 如果指针指向了一个对象，则允许使用解引用符(操作符*)来访问该对象

   ```cpp
   int ival = 42;
   int *p = &ival;	//p存放着变量ival的地址，或者说p是指向变量ival的指针
   cout << *p;	//由符号*得到指针p所指的对象，输出42
   ```

   + 解引用操作仅适用于那些确实指向了某个对象的有效指针。

##### 空指针

+ 不指向任何对象

+ 生成空指针的方法

  ```cpp
  int *p1 = nullptr;	//C++11新特性，常用
  int *p2 = 0;
  int *p3 = NULL;	//NULL：预处理变量
  ```

+ 在我们实际使用中要初始化所有的指针

##### 到底是改变指针的值还是指针的指向

1. 记住赋值永远改变的是等号左侧的对象

   ```cpp
   int *pi = nullptr;
   int ival = 66;
   
   pi = &ival;	//pi的值被改变，现在pi指向了ival;意思是为pi赋一个新的值，也就是改变了那个存放在pi内的地址值。
   *pi = 0;	//ival的值被改变，指针pi并没有改变。则*pi(也就是指针pi指向的那个对象)发生改变。
   ```

##### 指针比较

+ 任何非0指针对应的条件值都是true
+ 对于两个类型相同的合法指针，可以用相等操作符(==)或不相等操作符(!=)来比较他们，比较的结果是布尔类型。如果两个指针存放的地址相同，则他们相等；反之不相等。
+ 需要注意的是，一个指针指向某对象，同时另一个指针指向另外对象的下一地址，此时也有可能出现这两个指针值相同的情况，即指针相等。

##### void*指针

1. void指针是一种特殊的指针类型，可用于存放任意对象的地址。一个void指针存放着一个地址，这一点和其它指针类似。不同的是，我们对该地址中到底是个什么类型的对象并不了解。

   ```cpp
   double obj = 3.14, *pd = &obj;	//正确：void*能存放任意类型对象的地址
   void *pv = &obj;	//obj可以是任意类型的对象
   pv = pd;	//pv可以存放任意类型的指针
   ```

2. 不能直接操作void*指针所指向的对象，因为我们不知道这个对象到底是什么类型的。



## 二、字符串、向量和数组





## 三、表达式





## 四、语句





## 五、函数





## 六、类

